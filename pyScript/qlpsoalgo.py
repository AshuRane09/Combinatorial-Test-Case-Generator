# author - subhash from itertools import combinationsimport siximport stringfrom collections import OrderedDict, namedtuplefrom six.moves import range, reduce#from swarm_particles import SwarmParticle, keyimport randomfrom functools import cmp_to_keyimport jsonclass Particle_Node(object):    @property    def id(self):        return self.__node_id    @property    def counter(self):        return self.__counter    def __init__(self, node_id):        self.__node_id = node_id        self.__counter = 0        self.in_ = set()        self.out = set()    def __str__(self):        return str(self.__dict__)    def inc_counter(self):        self.__counter += 1key_cache = {}def key(items):    if items in key_cache:        return key_cache[items]    key_value = tuple([x.id for x in items])    key_cache[items] = key_value    return key_valueclass SwarmParticle(object):    def __init__(self, n):        self.__n = n        self.__position = {}        self.__velocity = [set() for _i in range(n)]            def __len__(self):        return len(self.__velocity[-1])    def addparticleswarm(self, sequence):        for i in range(1, self.__n + 1):            for combination in combinations(sequence, i):                self.addcombination(combination)    def getpositioninfo(self, item):        return self.__position.get(item.id, Particle_Node(item.id))    def get_velocity_matrix_with_pairs(self):        return self.__velocity    def addcombination(self, combination):        n = len(combination)        assert n > 0                self.__velocity[n - 1].add(key(combination))        if n == 1 and combination[0].id not in self.__position:            self.__position[combination[0].id] = Particle_Node(combination[0].id)            return        ids = [x.id for x in combination]        for i, id in enumerate(ids):            curr = self.__position[id]            curr.inc_counter()            curr.in_.update(ids[:i])            curr.out.update(ids[i + 1 :])class error:    def __init__(self):        self.errorCode="issue"        self.errorMessage="201"class BaseRespone():    def __init__(self):        self.success = "pairs fetch successfully"        self.data={"succss":"msg"}        self.error1 = error()def obj_to_dict(obj):   return obj.__dict__class PairsObjectItem(object):    @property    def id(self):        return self.__pair_item_id    @property    def value(self):        return self.__pair_value    @property    def weights(self):        return self.__matrix_cell_weights    def __init__(self, item_id, value):        self.__pair_item_id = item_id        self.__pair_value = value        self.set_weights([])    def __str__(self):        return str(self.__dict__)    def set_weights(self, weights):        self.__matrix_cell_weights = weightsdef getMaxCombinationForGivenParameter(prameter_matrix, n):    param_len_list = [len(value_list) for value_list in prameter_matrix]    return sum([reduce(lambda x, y: x * y, z) for z in combinations(param_len_list, n)])def comparePairsObjectItem(lhs, rhs):    if lhs.weights == rhs.weights:        #print("Compare Pair : 0 ",lhs," ",rhs)        return 0    #print("Compare Pair -1 or 1")    return -1 if lhs.weights < rhs.weights else 1#--------------------------------------------------------------------------------#class QlPSO(object):    apply=True    @staticmethod    def getAllValuesofX(item_list):        return [item.value for item in item_list]    def getParticleVelocityMatric(self, item_list):        if not self.paramnamelist:            return [item.value for item in item_list]        return self.pairsObject(*[item.value for item in item_list])    def getParameterNameList(self, parameters):        if not self.__is_ordered_dict_param:            return []        return list(parameters)    fact=0    def getValueMatrix(self, parameters):        if not self.__is_ordered_dict_param:            return parameters        return [v for v in six.itervalues(parameters)]    #initialize the QLPSO Algo        def __init__(self, parameters, filter_fitness_func=lambda x: True, previously_tested=None):        #print("PRR=" +str(len(parameters)))          #print("PRR1=" + str(len(parameters[0])))        #print(parameters)        #if str(len(parameters))=="4" and str(len(parameters[0]))=="3":        #    self.apply=False        if not previously_tested:            previously_tested = [[]]                self.scanparameter(parameters)# chewck for all valid parameters        self.__is_ordered_dict_param = isinstance(parameters, OrderedDict)#Checks if input is ordered dict:False        self.paramnamelist = self.getParameterNameList(parameters)#Empty List        self.__fitness_func = filter_fitness_func #True        self.__n = nosop = 2        self.__particles = SwarmParticle(nosop)  # Initialize Particles                valueMatrix = self.getValueMatrix(parameters)#Same As Parameters        self.maxUniquePairs = getMaxCombinationForGivenParameter(valueMatrix, nosop)#Calculte Pairs to Be covered.        self.pairsObject = namedtuple("Pairs", self.paramnamelist)#Tuple SubClass with named Fields                        self.paramtermatrix = self.mapPairsParametersMatric(valueMatrix)#[0,0][0,1][0,2][1,0][1,1][1,2]        #print("ParameterMatrix")        #for i in range(len(self.paramtermatrix)):        #    for j in range(len(self.paramtermatrix[i])):                #print(self.paramtermatrix[i][j])        #print("=====================================================")        #print(self.paramtermatrix)        '''        for param_idx, value_list in enumerate(valueMatrix):            for value_idx, value in enumerate(value_list):                #print(PairsObjectItem("p{:d}vl{:d}".format(param_idx, value_idx), value))'''            def __iter__(self):        return self    def __next__(self):        # TO be removed later -- vivek        return self.runPSO()    def runPSO(self):                #assert len(self.__particles) <= self.maxUniquePairs        #f = open("resultz.txt", "a")        #f.write("MAX UNIQUE PAIRS :" + str(self.maxUniquePairs) + "\n")        #print(self.__particles.get_velocity_matrix_with_pairs())        #f.write("CREATED PAIRS:\n" + str(self.__particles.get_velocity_matrix_with_pairs()) + "\n")                if len(self.__particles) == self.maxUniquePairs:  # Dont search further as we allready  have                                                           # all pairs            #print ("MAX UNIQUE PAIRS :" + str(self.maxUniquePairs) + "\n")            #f.write("MAX UNIQUE PAIRS :" + str(self.maxUniquePairs) + "\n")            raise StopIteration()        previous_unique_pairs_count = len(self.__particles)        chosen_pairs_list = [None] * len(self.paramtermatrix)        indexes = [None] * len(self.paramtermatrix)        direction = 1        i = 0        # no of iterations is fixed to parameter matrixs        while -1 < i < len(self.paramtermatrix):  #loops till all duplicates are removed            if direction == 1:                                # make the swarm move forward. Ensuse no swarm goes in out direction                ##print(self.paramtermatrix[i][0],"sdsa")                self.updateVelocityPositionMatrix(chosen_pairs_list[:i], i)                indexes[i] = 0                '''elif direction == 0 or direction == -1:                # get current array or make the swarm go back                indexes[i] += 1                if indexes[i] >= len(self.paramtermatrix[i]):                    direction = -1                    if i == 0:                        raise StopIteration()                    i += direction                    continue                direction = 0'''            else:                raise ValueError("swarm moving in unknown 'direction'  '{}'".format(direction))            '''#print("ParameterMatrix")            for k in range(len(self.paramtermatrix)):                for j in range(len(self.paramtermatrix[k])):                    #print(self.paramtermatrix[k][j])            '''            chosen_pairs_list[i] = self.paramtermatrix[i][indexes[i]]            #print("CHOSEN : ",self.paramtermatrix[i][0])            if self.__fitness_func(self.getAllValuesofX(chosen_pairs_list[: i + 1])):                assert direction > -1                direction = 1            else:                direction = 0            i += direction        if len(self.paramtermatrix) != len(chosen_pairs_list):            raise StopIteration()        self.__particles.addparticleswarm(chosen_pairs_list)                #print()        ##print("Possible Unique Pairs Created : " + str(previous_unique_pairs_count))        #print("Possible Unique Pairs Created : " + str(len(self.__particles)))        #print("-------------------------------------------------------------------------------")      #  #f.write("Possible Ubique Pairs Created : " + str(previous_unique_pairs_count))        #print()        #fx=self.calculateTunningValue(len(self.__particles),self.apply)        if len(self.__particles) == previous_unique_pairs_count:            # could not find new unique pairs - stop\            raise StopIteration()        # replace returned array elements with real values and return it             return self.getParticleVelocityMatric(chosen_pairs_list)        def scanparameter(self, value):        #print("PARA " + str(value))        if isinstance(value, OrderedDict):            for parameter_list in six.itervalues(value):                if not parameter_list:                    raise ValueError("each parameter must have at least one item")            return#        if len(value) < 2: #           raise ValueError("more than one option is necessary")        for parameter_list in value:            if not parameter_list:                raise ValueError("each parameter arrays must have at least one item")        '''def calculateTunningValue(self, value,apply):        #print("Tuning Value " + str(value))        if(apply==True):            fx= self.fact -value            fx=value - abs(fx)        else:            fx=0        return fx    '''    def updateVelocityPositionMatrix(self, chosen_pairs_list, num):        #print("\nUPDATEEEEEEEEEEEE-------------------------->\n")        for item in self.paramtermatrix[num]:            data_node = self.__particles.getpositioninfo(item)            #print("\nDATA ",data_node)            new_pairs_combination = [                # possible new pairs to be created if this item available                set([key(z) for z in combinations(chosen_pairs_list + [item], i + 1)])                - self.__particles.get_velocity_matrix_with_pairs()[i]                for i in range(0, self.__n)            ]            #print("\nnew_pairs_combination ",new_pairs_combination," ",[-len(new_pairs_combination[-1])])            # weighting the node that creates most of new pairs is the pbest            weights = [-len(new_pairs_combination[-1])]                        # extend weight list for nodes most likely to produce more new            # pairs while search continues            weights.extend(                [len(data_node.out)]                + [len(x) for x in reversed(new_pairs_combination[:-1])]                + [-data_node.counter]  # less used node pair is better            )            #QL -ve weights connections; somehow it works out better            weights.append(-len(data_node.in_))            #print("Weights",weights)            item.set_weights(weights)        self.paramtermatrix[num].sort(key=cmp_to_key(comparePairsObjectItem))    #def alignThreashold(self, size=6, chars=string.digits):    #   return ''.join(random.choice(chars) for x in range(size))    def mapPairsParametersMatric(self, parameter_matrix):        return [            [                PairsObjectItem("p{:d}vl{:d}".format(param_idx, value_idx), value)                                for value_idx, value in enumerate(value_list)            ]            for param_idx, value_list in enumerate(parameter_matrix)        ]